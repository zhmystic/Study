 Java语言特性最引以为傲的王牌，就是自动内存管理。可以归结为自动化的解决了两个问题：
1.对象内存分配问题，2.回收分配给对象的内存问题。主要活动区域就是Java堆。
正因为有了垃圾回收机制，我们在编写程序的时候才看似不用关心对象内存的释放问题，将其交由JVM管理。

对象被判定为垃圾的标准是什么？
    没有被任何对象所引用。
判定对象是否为垃圾的算法？
    1.引用计数算法
    2.可达性分析算法

1.引用计数算法
    通过判断对象的引用数量来决定对象是否可以被回收。
    堆中的每个对象实例都有一个引用计数器，被引用则+1，完成引用则-1。
    任何引用计数为0的对象实例可以被当作垃圾收集。
    优点：执行效率高，程序执行受影响较小。
    缺点：实现过于简单，无法检测出循环引用的情况，导致内存泄露。
    如图：
    调用：

    因为这个短板，主流的JAVA垃圾收集器并没有用这种机制去判断是否是垃圾。而是用的下一种。
2.可达性分析算法
    可达性算法是通过判断对象的引用链是否可达来决定对象是否可以被回收。

    如图所示，垃圾回收器会对内存中的整个对象图进行遍历，从根节点GC Root开始，根对象引用的其它对象，回收器将访问到的所有对象标记为存活。存活的对象就是可达的。当标记阶段完成之后，所有存活的对象都被标记完了，如上图4，5即为垃圾对象。
可以作为GC Root的对象？
    1.虚拟机栈中引用的对象（栈帧中的本地变量表），比如说在java里面new了一个对象并赋值给了局部变量，那么在该局部变量没有被销毁之前，new出来的这个对象即为GC Root。
    2.方法区中的常量引用的对象。
    3.方法区中的类静态属性引用的对象。
    4.本地方法栈中JNI（Native）的引用对象。
    5.活跃线程的引用对象呢。

谈谈垃圾回收算法
1.标记-清除算法（Mark and Sweep）
    将回收分为两个阶段：
    标记：通过可达性分析算法，从根集合进行扫描，对存活的对象进行标记；清除：对堆内存从头到尾进行线性遍历，回收不可达对象内存。
    缺点：因为标记清除不需要进行对象的移动，并且仅对不存活的对象进行处理，因此会产生大量不连续的内存碎片。空间碎片太多，可能会导致以后分配较大对象时无法分配连续内存。
2.复制算法（Copying）
    将可用内存按容量，按一定比例分为多个块，选取其中几块为对象面和空闲面。对象在对象面上创建。当被定义为对象面的内存块用完了的时候，就将还存活着的对象复制到其中一块空闲面上，再把已使用的内存空间一次清理掉。这种方法适合于对象成活率低的场景。
    优点：解决了碎片化的问题；顺序分配内存，简单高效；适用于对象成活率低的场景
    缺点：在面对对象成活率高的场景时就有些力不从心。
3.标记-整理算法（Compacting）
    标记-整理算法比较适合老年代的挥手。它采用标记-清除算法一样的标记，确定存活对象和可回收对象，但在清除的过程中，移动所有存活的对象，且按照内存地址次序依次排列，然后将末端内存地址以后的内存全部回收。也就是在标记-清除算法的基础上进行了移动，成本更高。但是解决了内存碎片的问题。
    优点：避免了内存的不连续性；不用设置两块内存互换；适用于对象存活率高的场景。
4.分代收集算法（Generational Collector）
    这个是比较主流的算法。相当于垃圾回收算法的组合拳。 
    它按照对象生命周期的不同，划分区域，以采用不同的垃圾回收算法。
    可以提高JVM的垃圾回收效率。
    JDK7和JDK7以前呢，堆内存一般可以分为年轻代（Young Generation），老年代（Old Generation），永久代（Permanent Generation）
    JDK8以后呢，永久代被去掉了，年轻代和老年代被保存下来。年轻代用复制算法，老年代用标记清除或标记整理算法。

分代收集算法的GC分为两种：
    1.Minor GC：是发生在年轻代中的垃圾收集动作，所采用的是复制算法。年轻代几乎是所有Java对象出生的地方，即Java对象申请的内存及存放都是在这个地方进行的，Java中的大部分对象通常不需要长久存活，具有朝生夕灭的兴致。新生代是GC回收垃圾的频繁区域。
    2.Full GC：下面讲解。
年轻代和老年代
    年轻代：年轻代的目标就是尽可能快速的收集掉那些生命周期短的对象。主要分为两个区。
    ①.Eden区
    ②.两个Survivor区（ from区和to区）
    绝大多数对象在Eden区生成。新生代中98%的对象都是朝生夕死的，所以并不需要按照1：1的比例来划分空间。

    老年代：存放生命周期较长的对象，经过一系列年轻代GC之后依然存活的对象。
    老年代采取标记清除算法或者标记整理算法。当触发老年代的垃圾回收的时候，通常也会伴随着对新生代堆内存的回收，即对这个堆进行垃圾回收，这便是所谓的Full GC。
    Full GC比Major GC慢，但执行频率低。
触发Full GC的条件：
1.老年代空间不足。假如创建一个大对象，Eden放不下，那就放入老年代，老年代放不下的话，触发Full GC。
2.永久代空间不足。（只针对JDK7及之前，JDK8取消了永久代）
3.CMS GC时出现promotion failed，concurrent mode failure。
4.Minor GC晋升到老年代的平均大小大于老年代的剩余时间。
5.在程序里面显示调用System.gc（）方法。这个方法只是码农提醒JVM回收，实际是否回收，咱们不清楚。
6.使用RMI来进行RPC或管理的JDK应用，每小时执行1次Full GC。

常用的调优参数
-XX:SurvivorRatio：Eden和Survivor的比值，默认为8：1
-XX:NewRatio：老年代和年轻代内存大小的比例
-XX:MaxTenuringThreshold：对象从哪个年轻代晋升到老生代经过GC次数的最大阈值，默认为15

Stop-the-World
    这个单词意味着JVM由于要执行GC停止了应用程序的执行；它在任何一种GC算法中都会发生。在发生GC时，所有线程统统进入等待状态。
    事实上，多数GC优化都是通过减少Stop-the-World发生的时间来提高程序性能。使系统拥有高吞吐，低停顿的特点。

常见的垃圾收集器
先说一下JVM的运行模式，有两种：
1.Server    启动较慢，启动时间长之后，运行速度快于Client
2.Client   启动较快
可以通过java -version来查看。

年轻代常见的垃圾收集器
1.Serial收集器（-XX：+UseSerialGC，复制算法）
    单线程收集，进行垃圾收集时，必须暂停所有工作线程。
    它简单高效，是Client模式下默认的年轻代收集器。
2.ParNew收集器（-XX：+UseParNewGC，复制算法）
    多线程收集，其余的行为特点都跟Serial收集器一样。
    单核执行效率不如Serial，在多核下执行才有优势。
3.Parallel Scavenge收集器（-XX：+UseParallelGC，复制算法）
    吞吐量 = 运行用户代码时间/（运行用户代码时间+垃圾收集时间）
    比起关注用户线程停顿时间，更关注系统的吞吐量。
    在多核执行才有优势，Server模式下默认的年轻代收集器。
老年代常见的垃圾收集器
1.Serial Old收集器（-XX：+UseSerialOldGC，标记-整理算法）（除了算法不一样，剩下的跟年轻代的Serial收集器都一样）
    单线程收集，进行垃圾收集时，必须暂停所有工作线程。
    它简单高效，是Client模式下默认的老年代收集器。
2.Parallel Old收集器（-XX：+UseParallelOldGC，标记-整理算法）
    多线程，吞吐量优先，这个是JDK6之后才开始提供。
3.CMS收集器（-XX：+UseConcMarkSweepGC，标记-清除算法）
    ①.初始化标记：stop-the-world
    ②.并发标记：并发追溯标记，程序不会停顿。
    ③.并发预清理：查找执行并发标记阶段从年轻代晋升到老年代的对象。
    ④.重新标记：暂停虚拟机，扫描CMS堆中的剩余对象。
    ⑤.并发清理：清理垃圾对象，程序不会停顿。
    ⑥.并发充值：充值CMS收集器的数据结构。
既用于年轻代，又用于老年代的收集器
1.G1收集器（-XX：+UseG1GC，复制+标记-整理算法）
    Garbage First收集器的特点：
    并行和并发
    分代收集
    空间整合
    可预测的停顿
使用G1收集器时，会将整个Java堆内存划分成多个大小相等的区域；年轻代和老年代不再物理隔离；
JDK11目前处于研发阶段：Epsilon GC 和 ZGC 很牛逼。不过还在研发中，吹吹牛逼就行了。
GC相关面试题
1.Object的finalize方法的作用是否与C++的析构函数作用相同？
    不同，析构函数调用确定，而它的是不确定的。
    将未被引用的对象放置于F-Queue队列。
    方法执行随时可能被终止。
    给予对象最后一次重生的机会。
2.Java中的强引用，软引用，弱引用，虚引用有什么作用？
    一.强引用：最普遍的引用，例如Object obj = new Object( )；这个Obj就属于强引用。
        当内存不足的时候，即使抛出OutOfMemoryError终止程序，也不会回收具有强引用的对象。
        所以我们可以通过将对象设置为null，来弱化引用，使其被回收。
    二.软引用：对象出在有用但非必须的状态。
        只有当内存空间不足的时候，GC会回收该引用的对象的内存。
        可以用来实现高速缓存。
    三.弱引用：非必须的对象，比软引用更弱一些。
        GC时会被回收。无论内存是否充足。
        被回收的概率也不大，因为GC线程优先级比较低。
        适用于引用偶尔被使用，且不影响垃圾手机的对象。
    四.虚引用：形同虚设，不会决定对象的生命周期。
        任何时候都可能被垃圾收集器回收。
        跟踪对象被垃圾收集器回收的活动，起哨兵作用。
        必须和引用队列ReferenceQueue联合使用。软引用和弱引用不是必须联合使用，下图代码可见。

代码举例：
String s = new String("abc");   //强引用
SoftReference<String> softRef = new SoftReference<String>(s);   //软引用
WeakReference<String> weakRef = new WeakReference<String>(s);   //弱引用
ReferenceQueue queue = new ReferenceQueue<>();
PhantomReference phantomRef = new PhantomReference(s,queue);    //虚引用
总结：
    
引用队列（ReferenceQueue）
    无实际存储结构，存储逻辑依赖于内部节点之间的关系来表达。
    存储关联的且被GC的软引用，弱引用以及虚引用。
    适用于引用偶尔被使用且不影响垃圾收集的对象。
    

