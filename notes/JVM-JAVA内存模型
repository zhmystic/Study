JAVA内存模型么？

刚才类加载主要讲的是Class Loader。现在，内存模型主要指的就是Runtime Data Area部分。
我们从线程的角度来看：
线程私有：
    1.虚拟机栈
    2.本地方法栈
    3.程序计数器
线程共享：
    1.堆
    2.元空间（MetaSpace）

程序计数器
    当前线程所执行的字节码行号指示器（逻辑）
    改变计数器的值来选取下一条需要执行的字节码指令。
    和线程是一对一的关系即“线程私有”
    对JAVA方法技术，如果是Native方法，那么计数器的值为Undefined
    不会发生内存泄露
Java虚拟机栈
    Java方法执行的内存模型
    包含多个栈帧，栈帧存储了局部变量表，操作栈等。
        局部变量表：包含方法执行过程中的所有变量。
        操作数栈：入栈，出栈，复制，交换，产生消费变量。
本地方法栈
    与虚拟机栈像是，主要作用于标注了native的方法。

元空间（MetaSpace）与永久代（PermGen）的区别
    在JDK8以后开始把类的元数据放在本地堆内存中，这一块区域就叫MetaSpace。该区域在JDK7及以前是属于永久代的。
    元空间和永久代都是用来存储class的相关信息，包括class对象的method,filed。
    前面我们提及过方法区。实际上，元空间和永久代都是方法区的实现。只是实现有所不同。方法区只是一种JVM的规范。
    在JAVA7之后，原先位于方法区里的字符串常量池已经被移动到了JAVA堆中，并且在JDK8中，使用了元空间替代了永久代。这不仅仅是名字上的替代，两者最大的区别是：
    1.元空间使用本地内存，而永久代使用的是JVM的内存。使用本地内存的好处是什么呢？之前出现的outofmemoryerror不会再轻易出现。
MetaSpace相比PermGen的优势
    字符串常量池存在于永久代中，容易出现性能问题和内存溢出。
    类和方法的信息大小难易确定，给永久代的大小指定带来困难。
    永久代会为GC带来不必要的复杂性。
    方便HotSpot与其它JVM如Jrockit的集成。

Java堆（Heap）
所有线程共享。所有对象的实例都在堆里面分配内存。
GC管理的主要区域。
常见面试题：
1.JVM三大性能调优参数-Xms -Xmx -Xss的含义？
    例如：java -Xms128m   -Xmx128m  -Xss256k -jar xxxx.jar
    -Xss：规定了每个线程虚拟机栈（堆栈）的大小，一般来说256K足够了。这个配置将会影响此进程中并发线程数的大小。
    -Xms：堆的初始值。
    -Xmx：Java堆能到达的最大值。
    通常情况下，我们都将xms和xmx设为最大值。
2.Java内存模型中堆和栈的区别？
    要研究这个问题，需要先研究下内存分配策略。
    首先，静态存储：编译时确定每个数据目标在运行时的存储空间需求。
    其次，栈式存储：数据区需求在编译时未知，运行时模块入口前确定。
    最后，堆式存储：编译时或运行时模块入口都无法确定，动态分配。
    堆和栈的联系： 引用对象，数组时，栈里定义变量保存堆中目标的首地址。
    区别主要在以下五个方面：
    1.管理方式：堆需要GC，栈自动释放。JVM自己可以对栈进行管理操作，而且该内存空间的释放是编译期就可以操作的内容。而堆，JVM不会对其进行释放，而是让垃圾回收器进行回收。
    2.空间大小：栈比堆小。因为堆空间需要存放大量的对象数据。
    3.碎片相关：栈产生的碎片远小于堆。
    4.分配方式：栈支持静态和动态分配，堆仅支持动态分配。是一个运行时级别的内存，而栈空间内存不需要考虑。
    5.效率：栈的效率比堆高。
3.不同JDK版本之间的intern（）方法的区别？—JDK6 VS JDK6+
    JDK6：当调用字符串的intern方法时，如果字符串常量池先前已经创建出该字符串对象，则返回池中的该字符串的引用。否则将此字符串对象添加到字符串常量池中，并且返回该字符串对象的引用。
    JDK6以后：当调用字符串的intern方法时，如果字符串常量池先前已经创建出该字符串对象，则返回池中的该字符串的引用；否则，如果该字符串已经存在于Java堆中，则将堆中对此对象的引用添加到字符串常量池中，并且返回该引用；如果堆中不存在，则在池中创建该字符串并返回其引用。
    对比可以看到，JDK6中仅会在字符串常量池里添加字符串对象。
    而JDK6以后版本非但能往池中添加字符串对象，还能添加字符串对象在堆中的引用。
