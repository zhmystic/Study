# 数据库的知识点：

* 架构
* 索引
* 锁
* 语法
* 理论范式


* * *


<u>**如何设计一个关系型数据库？**</u>
![0b5a41dbffdc8f3381c16383d6735f9f](Mysql.resources/30BE16F1-5640-477D-A31D-A0B11695C766.png)
首先要将其划分成两大部分：

*     一个是存储部分，该部分类似一个文件系统，将数据持久化到存储设备当中。

*     第二个是程序实例模块，来对存储进行逻辑上的管理。其应该包括如下的子模块
    *     数据的逻辑关系转换成物理存储管理的存储管理模块
    *     优化执行效率的缓存模块
    *     将SQL语句进行解析的SQL解析模块
    *     记录操作日志管理的日志管理模块
    *     记录多用户管理的权限划分模块
    *     灾难恢复模块
    *     优化数据查询效率的索引模块
    *     支持数据库并发操作的锁模块
    
    


# 索引

<u>**为什么要使用索引？**</u>
为了优化全表扫描的速度太慢。灵感是字典。
这样可以快速查询数据

<u>**什么样的信息能成为索引？**</u>
主键，唯一键，普通键等

<u>**索引的数据结构：**</u>
生成索引，建立二叉查找树进行二分查找
生成索引，建立B-Tree结构进行查找
生成索引，建立B+—Tree结构进行查找
生成索引，建立Hsah结构进行查找


* * *

### 索引的数据结构：

**1.二叉查找树：**
![4bbe3295992c0829f01b16e84335b26a](Mysql.resources/0E1A886E-1092-4EA7-8A2E-0D84E5E21074.png)

从根节点向下，分为左子树和右子树。左边比根小，右边比根大。
利用二分查找法，时间复杂度为O（logn）。
但是，假如一直在同一侧插入数据的话，那么复杂度会成为O（n）。
所以这不是好的办法。

**2.B-Tree**
![7958194c8d8d1b5f3cc4b071a8c2ba3e](Mysql.resources/9D56A1A4-3580-40D8-AAE7-219859BC94E2.png)

定义：

* 根节点至少包括两个孩子
* 树种每个节点最多含有m个孩子（m >= 2）
* 除根节点和叶节点外，其它每个节点至少有ceil/(m/2)个孩子
* 所有叶子节点都位于同一层


**3.B+-Tree**
![4f35b2b72dc67e318787f96fa065511f](Mysql.resources/85D0D7C8-F5CE-49CE-B8A9-FA3591128EA0.png)
B+树是B树的变体，其定义基本与B树相同。

B+Tree更适合用来做存储索引，原因如下：

* B+树的磁盘读写代价更低
* B+树的查询效率更加稳定
* B+树更有利于对数据库的扫描


**4.Hash**
![2b27320b1988e3bfc4fb9a3559d54a29](Mysql.resources/3D1D7C94-FBC2-415A-A653-61929EB42EF5.png)
虽然HASH索引的效率高，但是也有缺点：

* 仅能满足“=”，“IN”，不能使用范围查询
* 无法用来避免数据的排序操作
* 不能利用部分索引键查询
* 不能避免表扫描
* 遇到大量hash值相等的情况后，性能并不一定比B-Tree高


* * *

### 常见问题
<u>**密集索引和稀疏索引的区别：**</u>

* 密集索引文件中的每个搜索码值都对应一个索引值
* 稀疏索引文件只为索引码的某些值简历索引项

数据库的引擎一般常见的又InnoDB和MyISam,可以通过sql语句：
show create table + 表名  来查询。**默认为InnoDB**。
InnoDB：

* 若一个主键被定义，则主键作为密集索引
* 若没有主键被定义，该表的第一个唯一非空索引作为密集索引
* 若不满足以上条件，Innodb内部会生成一个隐藏主键（密集索引）
* 非主键索引存储相关键位和其对应的主键值，包含两次查找

    

* * *


### 如何调优sql
<u>**1.如何定位并优化慢查询sql**</u>
三个步骤：
* 根据慢日志定位慢查询sql
* 使用explain等工具分析sql
* 修改sql或者尽量让sql走索引



1. 根据慢日志定位慢查询sql
    一些常用的sql语句如下：
    show variables like 'slow_query_log'    查看是否开启慢查询日志，默认为OFF
    show status like '%slow_queries%'    查看本次会话慢sql的运行次数
    set global slow_query_log = on    开启慢查日志
    set global slow_query_log_file = '/usr/local/mysql/data/zhmysticdeMacBook-Pro-slow.log'    指定慢查询日志存储的文件位置
    set global log_queries_not_using_indexes = on    是否要把没有使用索引的SQL记录到日志中
    set global long_query_time = 1    设置慢查询时间为1秒，目前就是超过1秒就记录。这个值更新之后需要重启mysql
    **重启数据库之后，这些值就会还原，如果想更改的话，可以去配置文件修改。**

    慢日志里面有具体的查询时间，查询语句，以这个为准。工具显示的并不准确。

2. 使用explain分析语句
    直接在语句前面加explain。重点关注几个字段：
    
    type：index和all是本次查询走全表扫描，需要优化。
    extra：出现Using filesort和Using temporary意味着不能走索引，需要优化。Using index证明走索引了。
    key：走索引的字段。


3. sql调优
    尽量走索引。
    如果让某条语句强制走主键索引，在语句后面加：force index(primary)
    
举例问题：
    假如一个表，id为主键，语句：select count(id) form table;这个语句会走主键索引吗？
    答案是不会走，除非表中没有别的索引了。这是因为mysql的查询优化器的原因。
    


<u>**2.联合索引的最左匹配原则的成因**</u>

假如在A,B字段建立联合索引，根据A,B条件查询，和A条件，都会走索引；但是如果只有B条件，那么不会走索引。
*<u>**最左前缀匹配原则：mysql会一直向右匹配直到遇到范围查询（>,<,between,like）就停止匹配。**</u>*
假如：*<u>**a=3 and b=4 and c>5 and d=6。如果建立（a,b,c,d）联合索引的话，那么d是用不到索引的；如果建立（a,b,d,c）的话，那么都可以用得到。a,b,d的顺序可以任意调整。**</u>*


<u>**3.索引是建立的越多越好吗**</u>
那肯定不是啊。索引这个东西，一句话：空间换时间。

* 数据量小的表不需要建立所用，建立会增加额外的索引开销
* 数据变更需要维护索引，因此更多的索引意味着更多的维护成本
* 更多的索引意味着需要更多的空间




# 锁
 
### MyISAM与InnoDB关于锁方面的区别是什么？

答：
    MyISAM默认用的是表级锁，不支持行级锁；
    InnoDB默认用的是行级锁，也支持表级锁。

<u>**表级锁和行级锁：**</u>
    以MyISAM为例子，表级锁会锁住整张表。当表进行查询的时候，会自动给表加一个表级的读锁，对数据进行增删改的时候，对表自动加一个表级别的写锁。当读锁未被释放的时候，另外一个session想对同一张表加一个写锁的话，就会被阻塞。知道所有的读锁都被释放为止。
    行级锁的话就是只影响某一行的数据，而不是整张表。

<u>**如何显式给表加/释放读锁？**</u>
lock tables 表名 read;    读锁
unlock tables;  释放锁
也就是说，如果我们执行了lock tables 表名 read这个语句，我们再想执行增删改语句的时候，就被阻塞了，只有执行释放锁语句之后才可以。

<u>**共享锁和排它锁：**</u>
读锁有另外一个名字，叫共享锁。查询的时候，或者在语句后面加lock in share mode，都会给它加共享锁。
举例子，我们执行一条查询语句，查询前2000000条数据，这时候另一个session去查询第2000001条数据，依然是可以执行成功的。

写锁有另外一个名字，叫排它锁。增删改，或者select语句后面加for update，都会给它加排它锁。
举例子，我么执行一条更新语句，update前2000000条数据，这时候另一个session去查询第2000001条数据，会发现被锁住了，也就是说，不能上读锁了。需要等update执行完释放之后，才能执行。

结论：
一个session加了读锁之后，另一个session查询的话，是可以查询的。也就是说：
上了共享锁之后，依然支持上共享锁，不支持上排它锁；
上了排它锁之后，另外的读或者写都是不允许的。

<u>**查询InnoDB的事务是否自动提交：**</u>
show variables like 'autocommit';
默认为自动提交，如果想关闭自动提交的话，用如下语句：
set autocommit = 0;
该设置仅针对当前session，其它session依然为自动提交。

<u>**InnoDB的行级锁和表级锁：**</u>
用到表级锁的时候，只要操作表里数据的时候，均会上表锁，跟索引无关；当不走索引的时候，整张表都会被锁住。
所以，**InnoDB在没有用到索引的时候，用的是表级锁。
举例子：假如我现在通过name字段查询，name字段本身是没有索引的，我查询name=1的数据，这时候另一个session去修改（update）name=2的数据，虽然说InnoDB默认是行级锁，不应该影响这种不是同一行的数据，但是因为name字段没有索引，所以还是会被锁住。假如name有索引的话，就没关系，是行级锁。**

<u>**InnoDB和MYISAM的区别：**</u>
* InnoDB的索引和数据是存放在一起的；而MyISam的索引跟数据是分开存放的
* MyISam不支持事务，而InnoDB支持，且默认开启
* MyISAM不支持外键，InnoDB支持外键
* MYISAM支持全文索引，INNODB不支持
* MyISAM保存有表的总行数，如果select count（1） from table;会直接取出出该值；而InnoDB没有保存表的总行数(只能遍历)，如果使用select count(1) from table；就会遍历整个表，消耗相当大，但是在加了wehre条件后，myisam和innodb处理的方式都一样。
* 在CURD方面：
    MyISAM：如果执行大量的SELECT，MyISAM是更好的选择；
    InnoDB：如果你的数据执行大量的INSERT或UPDATE，出于性能方面的考虑，应该使用InnoDB表。DELETE 从性能上InnoDB更优，但DELETE FROM table时，InnoDB不会重新建立表，而是一行一行的删除，在innodb上如果要清空保存有大量数据的表，最好使用truncate table这个命令。
    
<u>**数据库锁的分类：**</u>

* 按锁的粒度划分，可分为表级锁，行级锁，页级锁
* 按锁级别划分，可分为共享锁，排它锁
* 按加锁方式划分，可分为自动锁，显式锁
* 按操作划分，可分为DML锁，DDL锁
* 按使用方式划分，可分为乐观锁，悲观锁


### 数据库事务的四大特性
ACID：

* 原子性：事务包含的所有操作，要么全部执行，要么全部失败回滚。
* 一致性：事务应确保数据库的状态，从一个一致状态转变为另一个一致状态。一致状态是指数据库数据满足完整性约束。典型例子就是转账。
* 隔离性：多个事务并发执行时，事务之间不会影响。（这个最重要，下面单独说）
* 持久性：一个事务一旦提交，它对数据库的修改应该永久保存在数据库中。持久性意味着当系统出现故障时，确保已提交事务的更新不能丢失。


### 事务并发访问产生的问题

通过select @@tx_isolation，可查看事务隔离性，默认为REPEATABLE-READ
<u>**设置事务隔离级别：**</u>
举例：设置为REPEATABLE-READ
    set session transacation isolation level repeatable read;


<u>**事务并发访问引起的问题以及如何避免：**</u>

* 更新丢失：Mysql所有事务隔离级别在数据库层面均可避免
* 脏读：一个事务读到另一个事务未提交的数据。
    * 通过设置事务隔离级别READ-COMMITED以上，即可避免。
* 不可重复读：多次读取数据的值不相同
    * 通过设置事务隔离级别REPEATABLE-READ，即可避免。
* 幻读：事务A读取与搜索条件相匹配的若干行，事务B以插入或删除行的方式来修改事务A的结果集，导致事务A像出现幻觉一样。
    * 通过设置事务隔离级别serializable，即可避免。


<u>**事务隔离级别：**</u>

| 事务隔离级别 | 脏读 | 不可重复读 | 幻读 |
| --- | --- | --- | --- |
| 未提交读（read-uncommitted）R-U|是  |  是|  是|
| 已提交读（read-committed）R-C | 否 | 是 | 是 |
| 可重复读（repeatable-read）R-R | 否 | 否 | 是 |
| 串行化（serializable）| 否 | 否 | 否 |

事务隔离级别越高，安全性越高，降低了数据库的并发度。
mysql默认为repeatable-read，oracle默认为read-committed。


### InnoDB可重复读隔离级别下如何避免幻读

<u>**如何避免？：**</u>

* 表面现象：快照读
* 实际：next-key锁（行锁+gap锁）
 
<u>**当前读和快照读：**</u>

当前读：
当前读，读取的是记录的最新版本，并且，当前读返回的记录，都会加上锁，保证其他事务不会再并发修改这条记录。
其实当前读就是sql语句中的增删改查语句，无论上的是共享锁还是排它锁，都是当前读，因为它读的是目前记录的最新版本。

* select...lock in share mode，select... for update
* update，delete，insert

快照读（非阻塞读）：
快照读，读取的是记录的可见版本 (有可能是历史版本)，不用加锁。
* select（前提条件是事务隔离级别不能是serializable，否则也退化成当前读）

举例子说明：

* 快照读：简单的select操作，属于快照读，不加锁。(当然，也有例外，下面会分析)
select * from table where ?;

* 当前读：特殊的读操作，插入/更新/删除操作，属于当前读，需要加锁。

    select * from table where ? lock in share mode;
    select * from table where ? for update;
    insert into table values (…);
    update table set ? where ?;
    delete from table where ?;

快照读有可能读到的不是最新版本。
在R-C隔离级别下，当前读和快照读读到的数据是一样的。
在R-R隔离级别下，快照读读到的有可能是历史版本。


<u>**next-key锁：**</u>

在R-R，以及serializable级别下，真正达到防止幻读目的的，是因为事务对数据加了next-key锁。
next-key锁分为两部分：

* 行锁（Record Lock）
    * 对单个一行上的锁
* 间隙锁（Gap lOCK）
    * 即锁定一个范围，但不包括记录本身。目的是防止同一事务的两次当前读出现幻读的情况。在RC及以下级别是没有的，所以无法避免幻读。在RR和SER以上都有。

<u>**思考：对主键索引或者唯一索引会用GAP锁吗？**</u>
在R-R下面，无论删，改，查，当前读用到主键，或者唯一键会用到GAP锁吗？有以下两种情况：
* 如果WHERE条件全部命中，则不会用GAP锁，只会加行锁；
    * 全部命中：假如select*from table where id in(1,3,5);假如id为主键或者唯一键。
    此时id为1，3，5均在此table中出现，即为全部命中。如果只有1，3则为部分命中。
* 如果WHERE条件部分命中或者全都不命中，则会加GAP锁。
    * 假如我删除一个id为7的数据，但是id里面没有7。同时另一个sission增加一个id为8的，发现被锁住了，因为已经加了GAP锁。GAP锁的范围，一会儿说。     

<u>**GAP锁主要出现在下面两种情况下：**</u>
1.走了非唯一索引
 GAP锁的范围跟我们走的非唯一索引的值有关，同时，也跟对应的主键值有关。一般都是左开右闭区间。如图：
![4996f3a8e576ee1885bf136b6c72f8ba](Mysql.resources/573821A6-343E-4FA2-BBD2-0721328009FA.png)

2.不走索引
如果不走索引的话，会对整个表都加GAP锁。


**总结一下，就是：**
InnoDB,RR级别主要通过引入NEXT-KEY锁来避免幻读问题，而NEXT-KEY由行锁RECORD LOCK和间隙锁GAP LOCK组成。
GAP间隙锁会用在非唯一索引或者不走索引的当前读
以及
即使走了唯一索引，但是仅命中检索条件的部分结果集。
只有走了唯一索引，且全部命中的情况下，加行锁，不加GAP锁。

**注意别记懵逼了！！！！
普通的select读只要不是SER级别的，都是快照读，不加锁！！！**
