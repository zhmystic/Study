#1.OSI七层协议
第一层：物理层
    机械，电子，定时接口通信信道上的原始比特流传输。物理层主要定义了网络设备的标准，如网线的类型，光纤接口类型，各种传输介质类型。主要作用就是传输比特流。这层的数据称为比特，网卡就是工作在这一层。
第二层：数据链路层
    物理寻址，同时将原始比特流转变为逻辑传输线路。交换机工作在这一层。
第三层：网络层
    主要功能就是将网络地址翻译成对应的物理地址，并决定如何将数据发送方路由到接收方。路由器属于网络层。本层的数据，成为数据包。本层需要关注的协议主要是TCP/IP协议里面的IP协议。
第四层：传输层
    传输层解决了层级间的数据传输。也解决了传输质量的问题。它接收上一层的数据，在必要的时候把数据进行分割，并将这些数据交给网络层，且保证这些数据段有效到达对端。该层为OSI模型中最重要的一层。传输层中需要关注的协议为TCP和UDP协议。
第五层：会话层
    建立并管理应用程序之间的通信。
第六层：表示层
    帮我们解决不同系统之间的通信语法的问题。在表示层，数据将按照网络能理解的方案进行格式化。
第七层：应用层
    规定发送方和接收方必须使用一个固定长度消息头，必须使用某种固定的组成。方便接收方能正确解析发送方发送的数据。没有该层也能传输数据，但是也就只是1或者0的字节数组了。该层关注的协议为HTTP协议。

#2.OSI的一种实现：TCP/IP
TCP/IP全称:Transmission Control Protocol / Internet Protocol ，中文翻译:传输控制协议 / 互联网协议。
提起TCP/IP可能第一感觉说的就是协议，其实不然，像HTTP，FTP，这些协议，都包括在TCP/IP协议之内。
TCP/IP概念层模型跟OSI原生的七层有些不同。
TCP/IP的应用层，约等于OSI的前三层（应用层，表示层，会话层）。
TCP/IP的传输层，等于OSI的传输层。
TCP/IP的网络层，等于OSI的网络层。
TCP/IP的链路层，约等于OSI的数据链路层和物理层。

#3.TCP协议
传输控制协议TCP：
    1.面向连接的，可靠的，基于字节流的传输层通信协议。
    2.数据传输时，将应用层的数据流分割成报文段，并发送给目标节点的TCP层。
    3.为了保证不丢失包，给每个包一个序号。数据包都有序号，对方收到则发送ACK确认，未收到则重传。
    4.使用校验和来校验数据在传输过程中是否有误。在发送和接收时都需要计算校验和。
TCP报文的头部：
    1.最上面是Source Port 和 Destination Port 分别表示源端口和目的地端口。他们各占两个字节。
       TCP和UDP的数据包，他们都不包含IP地址信息的，因为那是IP网络层上的事。但是他们都有源端口和目的地端口。
       就是说，端口这个东西，是属于传输层支持范畴的。我们知道两个进程在计算机内部进行通信时，可以通过管道，内存共享，信号量，消息队列等方法进行通讯。而连个进程要能进行通讯，最基本的一个前提是能够唯一的标识一个进程，通过这个唯一标识能够找到对应的进程。在本地进程通讯中，我们可以使用PID，即进程标识符，但是PID仅是在本地唯一。如果是两台不同的机器，那就不行了。解决这个问题的方法，就是在传输层中使用协议端口号，简称端口。
       我们知道IP层的IP地址可以唯一标识主机，而TCP协议和端口号可以唯一标识主机中的一个进程。所以我们可以利用IP地址+协议+端口号来唯一标识网络中的一个进程。在某些场合，也把这种唯一标识的模式称为套接字（socket）。
    2.下面是Sequence Number，我们的Seq序号，它也是占了4个字节。TCP连接中传送的字节流中的每个字节都是按顺序去编号的，例如一段报文的序号字段值是107，而携带的数据共有100个字段；如果有下一个报文段呢，其序号就应该是从107+100，也就是从207开始。
    3.再下面是Acknowledgment number，ACK确认号，同样占了4个字节。是期望收到对方下一个报文的第一个数据字节的序号。例如：B收到了A发送过来的报文，其序列号为301，而数据长度是200字节。这表明了B正确的收到了A发来的到序号500为止的数据。因此B期望收到A的下一个数据序号为501，于是B在发送给A的确认报文段中会把ACK确认号置为501。
    4. TCP Flags: 8个标志位，介绍下下面常见的6个
        URG：紧急指针标志
        ACK：确认序号标志
        PSH：Push标志
        RST：充值连接标志
        SYN：同步序号，用于建立连接过程
        FIN：用于释放连接
    5.window窗口
        指的是滑动窗口的大小，用来告知发送端，接收端的缓存大小，以此控制发送端发送的速率，达到流量控制。
#4.TCP的三次握手
“三次握手”是为了建立连接，TCP的三次握手流程如下：
    最开始的时候，A和B首次进行通信，客户端和服务器都会处于close状态。
    我们假设主动打开连接的是客户端，被动打开连接的是服务端。TCP服务器进程
    刚开始的时候，TCP服务器进程先创建传输控制块时刻准备接受其它客户进程发送过来的连接请求此时服务端进入了LISTEN监听状态；而此时我们的客户端也先创建传输控制块向服务端发送连接请求报文（SYN包），也就是我们TCP报文头里面的TCP flag里面的同步序号SYN，等于1。同时选择一个初始序号seq，等于X，这个X可以是一个随意的正整数值。此时TCP客户端进程就进入了SYN-SEND这么个同步已发送状态。此时发送过去的数据包及报文段是不能携带数据的，但是要消耗掉一个序号。这就是第一次握手了；
    当我们的服务器接收到请求报文之后，如果同意连接，则发出确认报文（SYN+ACK包），确认报文中包含了TCP Flag中的两个字段，一个是ACK，等于1；一个是SYN，也等于1。他的确认号ack是X+1。为什么ack是X+1呢，因为我们之前在报文里面指定了seq=X，作为回应，它要回应跟X相关的信息，并且由于上面的报文消耗了一个序号，因此它就成为了X+1。同时也要为自己的缓存初始化一个序列号，即seq=y。此时服务器进入了SYN-RCVD，即同步收到这么个状态。这个报文同样也是不能携带数据的。同样也需要消耗掉一个序号。这也就是第二次握手；
    当TCP客户进程收到确认报文后，还要给服务器一个确认报文（ACK包），报文的ACK=1，此时小的ack=y+1，原因是因为刚刚服务器发送过来个seq=y，作为回应。然后自己的序号也就是上面告诉我们的seq=X+1了。此时，TCP连接建立。客户端进入ESTAB-LISHED，已建立连接状态。TCP规定这个报文段可以携带数据，之前两个报文段都是不可以携带的。当然它也可以不携带，不携带的话就不消耗序号。这就是第三次握手。
简要总结三次握手：
    第一次握手：建立连接时，客户端发送SYN包（seq=x）到服务器，并进入SYN_SEND状态，等待服务器确认。
    第二次握手：服务器收到了客户端发送的SYN包，必须确认客户的SYN（ack=X+1），同时自己也发送一个SYN包（seq=y），即SYN+ACK包，此时服务器进入SYN_RECV状态。
    第三次握手：客户端收到服务器的SYN_ACK包，向服务器发送确认包ACK（ack=y+1），此包发送完毕，客户端和服务器进入ESTABLISHED状态，三次握手完成。
为什么需要三次握手才能建立起连接？
    为了初始化Sequence Number的初始值。
首次握手的隐患？
    服务器数到客户端的SYN，回复的时候，客户端凉凉了，没收到ACK确认。这个连接就会处于中间状态。服务器不断尝试直至超时，默认次数为五次，也就是是默认等待63（1+2+4+8+16+32）秒才断开连接。        
    这可能会被造成攻击，为了应对这个事，LINUX下给了一个tcp_syncookies的参数来应对这个问题，当SYN队列满了之后，TCP会根据源地址端口，目标地址端口，时间戳打造出一个特别的seq number回发回去，简称SYN cookie。如果是攻击者呢是不会有响应的，如果是正常连接，客户端则会把这个SYN cookie发回来，直接建立连接。
建立连接后，客户端突然出现故障怎么办？
    保活机制，向对方发送保活探测报文，如果未收到相应则继续发送。尝试次数达到保活探测数扔未收到相应，则中断连接。

#5.TCP的四次挥手
“四次挥手”是为了终止连接。流程如下：
    断开一个TCP连接时，客户端和服务器一共需要发送4个包，确认连接关闭。    
    我们假设客户端主动关闭，服务端被动关闭。
    首先，客户端发送释放报文，并且停止发送数据，在释放报文段中，TCP Flag中的FIN，就等于1，假设此时seq=u（也就是前面ESTABLISHED状态下数据最后一次发送的时候传过来的字节序号加上1），此时客户端进入FIN-WAIT-1这么一个状态。这即使不携带数据，也会消耗掉一个序号。这就是第一次挥手。
    服务器端收到释放报文之后，要回发给客户端确认报文，ACK=1，ack=u+1，并且携带自己的序列号seq=v，此时，服务端进入了CLOSE-WAIT的状态。这就是第二次挥手。
    客户端接收到服务器端的回传报文之后，进入了FIN-WAIT-2状态。等待服务器发送释放连接报文，也就是等待服务器端发送第三次挥手。
    第三次挥手之后，服务器端进入了LAST-ACK状态，等待客户端的最终确认。
    客户端接收到之后，必须回传给服务器端，进入TIME-WAIT状态。但是此时客户端连接并没有释放进入close状态，必须经过2*MSL时间才可以进入close状态（linux默认为30秒），而服务器端在接到客户端回传之后，会立刻进入CLOSE状态。
简单总结四次挥手？
    第一次挥手：客户端发送一个FIN，用来关闭客户端到服务器的数据传送，客户端进入FIN-WAIT-1状态。
    第二次挥手：服务器端接收到FIN后，发送一个ACK给客户端，确认序号为收到序号+1，然后服务器端进入CLOSE-WAIT状态。
    第三次挥手：服务端发送一个FIN，用来关闭客户端服务器数据传送，服务器进入LAST-ACK状态。
    第四次挥手：客户端接收到FIN，进入TIME-WAIT状态，接着发送一个ACK给服务器端。服务器进入CLOSED状态，完成挥手。
为什么会有TIME-WAIT状态？
    确保有足够的时间让对方收到ACK包。
    避免新旧连接混淆。
为什么需要四次挥手才能断开连接？
    因为TCP是全双工的，所以发送方和接收方都需要FIN报文和ACK报文。

#6.HTTP协议
超文本传输协议HTTP协议
    工作于客户端/服务器之上。简单快速。灵活。无连接（限制每次连接只处理一个请求，节省传输时间）。无状态。
    HTTP1.1照比1.0引入了keep-alive这个长连接技术。
HTTP协议定义了WEB客户端如何从WEB服务器请求WEB页面，以及服务器如何把数据传送给客户端？
    HTTP协议采用了请求/相应模型，客户端向服务器发送了一个请求报文，请求报文包含了请求方法，URL，协议版本，请求头部，请求数据。服务器接收请求并返回HTTP响应；释放TCP连接。浏览器解析内容。
面试题：在浏览器地址栏键入URL，按下回车之后经历怎样的流程？
    首先DNS解析：浏览器会根据URL，逐层查询DNS服务器缓存，解析URL中的域名所对应的IP地址。DNS缓存从近到远依次是：浏览器缓存，系统缓存，路由器缓存，IPS服务器缓存，根域名服务器缓存，顶级域名服务器缓存。从哪个缓存找到对应的域名则直接返回不再查询下面的缓存。
    找到该IP地址之后，根据IP，端口，和服务器建立TCP连接，三次握手流程说起来。
    然后浏览器发送HTTP请求，HTTP请求流程说起来。
    然后服务器处理请求并返回HTTP响应报文。
    最后浏览器解析，并渲染页面。连接结束。
HTTP状态码：
    1xx：指示信息，标识请求已被接收。
    2xx：正常，请求被成功接收。
    3xx：重定向，要完成请求必须进行更进一步的操作。
    4xx：客户端错误，请求有语法错误或请求无法实现。
    5xx：服务器端错误，服务器未能实现合法请求。
常见状态码：
    200 OK：正常返回。
    400 Bad Request：客户端请求有语法错误，不能被服务器所理解。
    401 Unauthorized：请求未经授权。
    403 Forbidden：服务器收到请求，但是拒绝提供服务。
    404 Not Found：请求资源不存在。
    500 Internal Server Error：服务器发生不可预期的错误。
    503 Server Unavaliable：服务器当前不能处理客户端请求，一段时间后可恢复正常。
GET请求和POST请求的区别？
    从三个层面来解答：
    1.从HTTP报文层面来看：GET请求将请求信息放在URL，长度是会有限制的。而POST请求放在报文体中。想获得请求信息必须解析报文。安全性稍微高一些，但是实际并没有高多少。抓包还是能抓得到。具体解决方式还得靠HTTPS。
    2.从数据库层面来看：GET请求符合幂等性和安全性，POST不符合。因为GET请求主要做查询操作，所以不会更改数据库数据。幂等性问题就是对数据库的一次操作和多次操作获得的结果是一样的。
    3.其它层面：GET可以被缓存，被存储。而POST请求不可以。
Cookie和Session的区别？
Cookie:
    因为HTTP是无状态的，所以意味着我们每次访问一个登陆页面的时候都得输入账号密码，但是其实并没有，这就是因为cookie和session的原因。
    Cookie是由服务器发给客户端的特殊信息，以文本的形式存放在客户端；客户端再次请求的时候，会把cookie回发；服务器接收到后，会解析Cookie生成与客户端相对应的内容。
    Cookie的设置及发送过程：首先客户端发送HTTP请求到服务器端；服务器端响应回去客户端，里面包括set cookie这个头部；客户端再发送HTTP请求到服务器端，包括了Cookie头部；此时服务器端再响应回去。
Session:
    服务器端机制，在服务器上保存的信息；当程序需要为某个客户端请求创建一个session的时候，服务器首先检查这个客户端请求里是否包含session id。如果包含，说明以前为此创建过session，那么揪根据session id来检索出来。如果客户端请求不包含session id的话，则为此客户端创建一个session，并且生成一个与此对应的session id。值为不重复，无规律，随机的字符串，该session id会跟随这次响应返回回去。
    session的实现方式：
        1.使用cookie来实现：服务器给每个session分配一个唯一的JSESSION ID，并通过cookie发送给客户端，当客户端发送新的请求的时候，将在cookie头中携带这个JSESSION ID
        2.使用URL回写来实现：URL中有这个参数。
区别：
    1.Cookie存放在浏览器中，Session存放在服务器中。
    2.Session相对于cookie更安全。
    3.Session会在一定时间存放在服务器中，若考虑服务器开销，应适当使用cookie。

#7.HTTP和HTTPS的区别

相比较于HTTP，HTTPS加入了SSL层，比较安全。
SSL是什么？
    Security Sockets Lsyer，安全套接层。
    为网络通信提供安全及数据完整性的一种安全协议。
    是操作系统对外的API，SSL3.0后更名为TLS。
    采用身份验证和数据加密保证网络通信的安全和数据的完整性。
HTTPS数据传输流程？
    1.浏览器将支持的加密算法信息发送给服务器。
    2.服务器选择一套浏览器支持的加密算法，以证书的形式回发浏览器。
    3.浏览器验证证书合法性，并结合证书公钥加密信息发送给服务器。
    4.服务器使用私钥解密信息，验证哈希，加密响应信息回发浏览器。
    5.浏览器解密响应消息，并对消息进行验真，之后进行加密交互数据。
两者区别：
    1.HTTPS需要到CA申请证书，HTTP不需要。
    2.HTTPS密文传输，HTTP明文传输。
    3.连接方式不同，HTTPS默认使用443端口，HTTP默认使用80端口。
    4.HTTPS=HTTP+加密+认证+完整性保护，比HTTP安全。

#8.Socket
Socket概念：
    两个进程之间如果需要进行通信，最基本的一个前提，是能够唯一标识一个进程。在本地进程通信中，我们可以使用PID来唯一标识一个进程，但是PID只是在本地唯一。网络中两个进程PID冲突还是有的。我们知道IP层的IP地址可以唯一标识一台主机，而TCP协议和端口号可以唯一标识主机的一个进程。所以我们可以使用IP地址+协议+端口号来唯一标识网络中的一个进程。然后，我们就可以利用socket进行通信了。
    Socket是对TCP/IP协议的抽象，是操作系统对外开放的接口。Socket的出现，使程序员更简单的使用TCP/IP协议。

Socket通信流程：

Socket面试题
    编写一个网络应用程序，有客户端和服务器端，客户端向服务器发送一个字符串，服务器收到该字符串后将其打印到命令行上，然后向客户端返回该字符串的长度，分别用TCP和UDP两种方式去实现。
    UDP的就不实现了。下面分别用传统IO和NIO方式进行实现吧。
    传统IO方式：
    服务端：
    逻辑部分：
    客户端部分：

NIO方式：
    服务器端：
    逻辑部分：
    客户端：

#9.TCP的滑动窗口
RTT和RTO概念：
    RTT：发送一个数据包到收到对应的ACK，花费的时间。
    RTO：重传时间间隔。它不是固定写死的配置，是根据RTT计算出来的。
TCP使用滑动窗口做流量控制与乱序重排
    保证TCP的可靠性
    保证TCP的流控特性

